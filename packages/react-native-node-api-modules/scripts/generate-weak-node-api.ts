import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";

import {
  type NodeApiVersion,
  symbols,
  include_dir as nodeApiIncludePath,
} from "node-api-headers";
import { z } from "zod";

export const WEAK_NODE_API_PATH = path.join(__dirname, "../weak-node-api");

export function generateVersionScript(
  libraryName: string,
  globalSymbols: string[]
) {
  return [
    `${libraryName} {`,
    `  global:`,
    ...globalSymbols.map((symbol) => `    ${symbol};`),
    `  local: *;`,
    `};`,
  ].join("\n");
}

const clangAstDump = z.object({
  kind: z.literal("TranslationUnitDecl"),
  inner: z.array(
    z.object({
      kind: z.string(),
      name: z.string().optional(),
      type: z
        .object({
          qualType: z.string(),
        })
        .optional(),
    })
  ),
});

/**
 * Generates source code for a version script for the given Node API version.
 * @param version
 */
export function getNodeApiHeaderAST(version: NodeApiVersion) {
  const output = cp.execFileSync(
    "clang",
    [
      // Declare the Node API version
      "-D",
      `NAPI_VERSION=${version.replace(/^v/, "")}`,
      // Pass the next option directly to the Clang frontend
      "-Xclang",
      // Ask the Clang frontend to dump the AST
      "-ast-dump=json",
      // Parse and analyze the source file but not compile it
      "-fsyntax-only",
      // Include from the node-api-headers package
      `-I${nodeApiIncludePath}`,
      path.join(nodeApiIncludePath, "node_api.h"),
    ],
    {
      encoding: "utf-8",
      // Emitting the AST can produce a lot of output
      maxBuffer: 1024 * 1024 * 10,
    }
  );
  const parsed = JSON.parse(output);
  return clangAstDump.parse(parsed);
}

type FunctionDecl = {
  name: string;
  returnType: string;
  argumentTypes: string[];
  libraryPath: string;
  fallbackReturnStatement: string;
};

export function generateNodeApiFunctionStubBody({
  name,
  returnType,
  argumentTypes,
  libraryPath,
  fallbackReturnStatement,
}: FunctionDecl) {
  const returnStatement =
    name === "napi_fatal_error"
      ? "abort();"
      : returnType === "void"
      ? ""
      : `return real_func(${argumentTypes
          .map((t, index) => `arg${index}`)
          .join(", ")}); // Call the real function`;
  return `
    static ${name}_t real_func = NULL;

    if (!real_func) {
        void* handle = dlopen("${libraryPath}", RTLD_LAZY | RTLD_GLOBAL);
        if (!handle) {
            fprintf(stderr, "Failed to load ${libraryPath} while deferring ${name}: %s\\n", dlerror());
            ${fallbackReturnStatement}
        }

        real_func = (${name}_t)dlsym(handle, "${name}");
        if (!real_func) {
            fprintf(stderr, "Failed to find symbol while deferring ${name}: %s\\n", dlerror());
            ${fallbackReturnStatement}
        }
    }

    ${returnStatement}
  `;
}

export function generateNodeApiFunction(decl: FunctionDecl) {
  const { name, returnType, argumentTypes, fallbackReturnStatement } = decl;
  return `
typedef ${returnType} (*${name}_t)(${argumentTypes.join(", ")});
${returnType} ${name}(${argumentTypes
    .map((type, index) => `${type} arg${index}`)
    .join(", ")})  {
    fprintf(stdout, "Calling ${name} [weak-node-api]\\n");
    #ifdef NODE_API_REEXPORT
    ${generateNodeApiFunctionStubBody(decl)}
    #else
    fprintf(stderr, "Returning generic error for ${name}\\n");
    ${fallbackReturnStatement}
    #endif
}`;
}

/**
 * Generates source code for a version script for the given Node API version.
 * @param version
 */
export function generateFakeNodeApiSource(version: NodeApiVersion) {
  const lines = [
    "// This file is generated by react-native-node-api-modules",
    "#include <node_api.h>", // Node-API
    "#include <dlfcn.h>", // dlopen(), dlsym()
    "#include <stdio.h>", // fprintf()
    "#include <stdlib.h>", // abort()
  ];
  const root = getNodeApiHeaderAST(version);
  assert.equal(root.kind, "TranslationUnitDecl");
  assert(Array.isArray(root.inner));
  const foundSymbols = new Set();

  const symbolsPerInterface = symbols[version];
  const engineSymbols = new Set(symbolsPerInterface.js_native_api_symbols);
  const runtimeSymbols = new Set(symbolsPerInterface.node_api_symbols);
  const allSymbols = new Set([...engineSymbols, ...runtimeSymbols]);

  for (const node of root.inner) {
    const { name, kind } = node;
    if (kind === "FunctionDecl" && name && allSymbols.has(name)) {
      assert(name, "Expected a name");
      foundSymbols.add(name);
      assert(node.type, `Expected type for ${node.name}`);

      const match = node.type.qualType.match(
        /^(?<returnType>[^(]+) \((?<argumentTypes>[^)]+)\)/
      );
      assert(
        match && match.groups,
        `Failed to parse function type: ${node.type.qualType}`
      );
      const { returnType, argumentTypes } = match.groups;
      assert(
        returnType,
        `Failed to get return type from ${node.type.qualType}`
      );
      assert(
        argumentTypes,
        `Failed to get argument types from ${argumentTypes}`
      );
      assert(
        returnType === "napi_status" || returnType === "void",
        `Expected return type to be napi_status, got ${returnType}`
      );

      lines.push(
        generateNodeApiFunction({
          name,
          returnType,
          argumentTypes: argumentTypes.split(",").map((arg) => arg.trim()),
          // Defer to the right library
          libraryPath: engineSymbols.has(name)
            ? "libhermes.so"
            : "libnode-api-host.so",
          fallbackReturnStatement:
            returnType === "void"
              ? "abort();"
              : "return napi_status::napi_generic_failure;",
        })
      );
    }
  }
  for (const knownSymbol of allSymbols) {
    if (!foundSymbols.has(knownSymbol)) {
      throw new Error(
        `Missing symbol '${knownSymbol}' in the AST for Node API ${version}`
      );
    }
  }
  return lines.join("\n");
}

async function run() {
  const sourceCode = generateFakeNodeApiSource("v10");
  await fs.promises.mkdir(WEAK_NODE_API_PATH, { recursive: true });
  await fs.promises.writeFile(
    path.join(WEAK_NODE_API_PATH, "weak-node-api.cpp"),
    sourceCode,
    "utf-8"
  );
}

run().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
