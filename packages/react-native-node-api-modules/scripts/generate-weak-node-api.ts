import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";

import {
  type NodeApiVersion,
  symbols,
  include_dir as nodeApiIncludePath,
} from "node-api-headers";
import { z } from "zod";

export const WEAK_NODE_API_PATH = path.join(__dirname, "../weak-node-api");

export function generateVersionScript(
  libraryName: string,
  globalSymbols: string[]
) {
  return [
    `${libraryName} {`,
    `  global:`,
    ...globalSymbols.map((symbol) => `    ${symbol};`),
    `  local: *;`,
    `};`,
  ].join("\n");
}

const clangAstDump = z.object({
  kind: z.literal("TranslationUnitDecl"),
  inner: z.array(
    z.object({
      kind: z.string(),
      name: z.string().optional(),
      type: z
        .object({
          qualType: z.string(),
        })
        .optional(),
    })
  ),
});

/**
 * Generates source code for a version script for the given Node API version.
 * @param version
 */
export function getNodeApiHeaderAST(version: NodeApiVersion) {
  const output = cp.execFileSync(
    "clang",
    [
      // Declare the Node API version
      "-D",
      `NAPI_VERSION=${version.replace(/^v/, "")}`,
      // Pass the next option directly to the Clang frontend
      "-Xclang",
      // Ask the Clang frontend to dump the AST
      "-ast-dump=json",
      // Parse and analyze the source file but not compile it
      "-fsyntax-only",
      // Include from the node-api-headers package
      `-I${nodeApiIncludePath}`,
      path.join(nodeApiIncludePath, "node_api.h"),
    ],
    {
      encoding: "utf-8",
      // Emitting the AST can produce a lot of output
      maxBuffer: 1024 * 1024 * 10,
    }
  );
  const parsed = JSON.parse(output);
  return clangAstDump.parse(parsed);
}

type FunctionDecl = {
  name: string;
  returnType: string;
  argumentTypes: string[];
  libraryPath: string;
  fallbackReturnStatement: string;
};

export function getNodeApiFunctions(version: NodeApiVersion) {
  const root = getNodeApiHeaderAST(version);
  assert.equal(root.kind, "TranslationUnitDecl");
  assert(Array.isArray(root.inner));
  const foundSymbols = new Set();

  const symbolsPerInterface = symbols[version];
  const engineSymbols = new Set(symbolsPerInterface.js_native_api_symbols);
  const runtimeSymbols = new Set(symbolsPerInterface.node_api_symbols);
  const allSymbols = new Set([...engineSymbols, ...runtimeSymbols]);

  const nodeApiFunctions: FunctionDecl[] = [];

  for (const node of root.inner) {
    const { name, kind } = node;
    if (kind === "FunctionDecl" && name && allSymbols.has(name)) {
      assert(name, "Expected a name");
      foundSymbols.add(name);
      assert(node.type, `Expected type for ${node.name}`);

      const match = node.type.qualType.match(
        /^(?<returnType>[^(]+) \((?<argumentTypes>[^)]+)\)/
      );
      assert(
        match && match.groups,
        `Failed to parse function type: ${node.type.qualType}`
      );
      const { returnType, argumentTypes } = match.groups;
      assert(
        returnType,
        `Failed to get return type from ${node.type.qualType}`
      );
      assert(
        argumentTypes,
        `Failed to get argument types from ${argumentTypes}`
      );
      assert(
        returnType === "napi_status" || returnType === "void",
        `Expected return type to be napi_status, got ${returnType}`
      );

      nodeApiFunctions.push({
        name,
        returnType,
        argumentTypes: argumentTypes.split(",").map((arg) => arg.trim()),
        // Defer to the right library
        libraryPath: engineSymbols.has(name)
          ? "libhermes.so"
          : "libnode-api-host.so",
        fallbackReturnStatement:
          returnType === "void"
            ? "abort();"
            : "return napi_status::napi_generic_failure;",
      });
    }
  }
  for (const knownSymbol of allSymbols) {
    if (!foundSymbols.has(knownSymbol)) {
      throw new Error(
        `Missing symbol '${knownSymbol}' in the AST for Node API ${version}`
      );
    }
  }

  return nodeApiFunctions;
}

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateHeader(nodeApiFunctions: FunctionDecl[]) {
  return [
    "// This file is generated by react-native-node-api-modules",
    "#include <node_api.h>", // Node-API
    "#include <stdio.h>", // fprintf()
    "#include <stdlib.h>", // abort()
    "namespace node_api::internal {",
    // Generate the struct of function pointers
    "struct NodeApiHost {",
    ...nodeApiFunctions.map(
      ({ returnType, name, argumentTypes }) =>
        `${returnType} (*${name})(${argumentTypes.join(", ")});`
    ),
    "};",
    "void inject_host(const NodeApiHost& host);",
    "} // namespace node_api::internal",
  ].join("\n");
}

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateSource(nodeApiFunctions: FunctionDecl[]) {
  return [
    "// This file is generated by react-native-node-api-modules",
    "#include <weak_node_api.hpp>", // Generated header
    "namespace node_api::internal {",
    // Generate the struct of function pointers
    "NodeApiHost g_host;",
    "void inject_host(const NodeApiHost& host) {",
    "  g_host = host;",
    "};",
    "} // namespace node_api::internal",
    "using node_api::internal::g_host;",
    // Generate function calling into the host
    ...nodeApiFunctions.flatMap(({ returnType, name, argumentTypes }) => {
      return [
        `${returnType} ${name}(${argumentTypes
          .map((type, index) => `${type} arg${index}`)
          .join(", ")}) {`,
        `if (g_host.${name} == nullptr) {`,
        `  fprintf(stderr, "Node-API function '${name}' called before it was injected!\\n");`,
        "  abort();",
        "}",
        (returnType === "void" ? "" : "return ") +
          "g_host." +
          name +
          "(" +
          argumentTypes.map((_, index) => `arg${index}`).join(", ") +
          ");",
        "};",
      ];
    }),
  ].join("\n");
}

async function run() {
  await fs.promises.mkdir(WEAK_NODE_API_PATH, { recursive: true });

  const nodeApiFunctions = getNodeApiFunctions("v10");

  const header = generateHeader(nodeApiFunctions);
  const headerPath = path.join(
    WEAK_NODE_API_PATH,
    "include",
    "weak_node_api.hpp"
  );
  await fs.promises.writeFile(headerPath, header, "utf-8");
  cp.spawnSync("clang-format", ["-i", headerPath], { stdio: "inherit" });

  const source = generateSource(nodeApiFunctions);
  const sourcePath = path.join(WEAK_NODE_API_PATH, "weak_node_api.cpp");
  await fs.promises.writeFile(sourcePath, source, "utf-8");
  cp.spawnSync("clang-format", ["-i", sourcePath], { stdio: "inherit" });
}

run().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
