import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";

import { FunctionDecl, getNodeApiFunctions } from "./node-api-functions";

export const WEAK_NODE_API_PATH = path.join(__dirname, "../weak-node-api");

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateHeader(functions: FunctionDecl[]) {
  return [
    "// This file is generated by react-native-node-api",
    "#include <node_api.h>", // Node-API
    "#include <stdio.h>", // fprintf()
    "#include <stdlib.h>", // abort()
    // Generate the struct of function pointers
    "struct WeakNodeApiHost {",
    ...functions.map(
      ({ returnType, noReturn, name, argumentTypes }) =>
        `${returnType} ${
          noReturn ? " __attribute__((noreturn))" : ""
        }(*${name})(${argumentTypes.join(", ")});`
    ),
    "};",
    "typedef void(*InjectHostFunction)(const WeakNodeApiHost&);",
    `extern "C" void inject_weak_node_api_host(const WeakNodeApiHost& host);`,
  ].join("\n");
}

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateSource(functions: FunctionDecl[]) {
  const interceptModuleRegisterCalls = true;
  return [
    "// This file is generated by react-native-node-api",
    `#define WITH_DEFERRED_NAPI_MODULE_REGISTER ${interceptModuleRegisterCalls ? 1 : 0}`,
    `#include "weak_node_api.hpp"`, // Generated header
    "",
    // Declare globals needed for bookkeeping intercepted calls
    "#if WITH_DEFERRED_NAPI_MODULE_REGISTER",
    "#include <mutex>",
    "#include <vector>",
    "std::mutex g_internal_state_mutex;",
    "std::vector<napi_module*> g_pending_modules;",
    "#endif // WITH_DEFERRED_NAPI_MODULE_REGISTER",
    "",
    // Generate the struct of function pointers
    "WeakNodeApiHost g_host;",
    "void inject_weak_node_api_host(const WeakNodeApiHost& host) {",
    "  g_host = host;",
    "",
    "#if WITH_DEFERRED_NAPI_MODULE_REGISTER",
    "  // Flush pending `napi_module_register()` calls",
    "  if (nullptr != host.napi_module_register) {",
    "    std::lock_guard<std::mutex> lock(g_internal_state_mutex);",
    "    fprintf(stderr,",
    `      "Flushing %zu intercepted calls to 'napi_module_register'...\\n",`,
    "      g_pending_modules.size());",
    "    for (napi_module *module : g_pending_modules) {",
    "      host.napi_module_register(module);",
    "    }",
    "    g_pending_modules.clear();",
    "  }",
    "#endif // WITH_DEFERRED_NAPI_MODULE_REGISTER",
    "};",
    "",
    // Generate function calling into the host
    ...functions.flatMap(({ returnType, noReturn, name, argumentTypes }) => {
      const isDeferrable = name === "napi_module_register";
      return [
        `extern "C" ${returnType} ${
          noReturn ? " __attribute__((noreturn))" : ""
        }${name}(${argumentTypes
          .map((type, index) => `${type} arg${index}`)
          .join(", ")}) {`,
        `if (g_host.${name} == nullptr) {`,
        `  fprintf(stderr, "Node-API function '${name}' called before it was injected!\\n");`,
        ...(isDeferrable ? [
          "#if WITH_DEFERRED_NAPI_MODULE_REGISTER",
          "  {",
          "    std::lock_guard<std::mutex> guard(g_internal_state_mutex);",
          "    g_pending_modules.push_back(arg0);",
          "  }",
          "#else",
          "  abort();",
          "#endif // WITH_DEFERRED_NAPI_MODULE_REGISTER",
        ] : [
          "  abort();",
        ]),
        "} else {",
        "  " + (returnType === "void" ? "" : "return ") +
          "g_host." +
          name +
          "(" +
          argumentTypes.map((_, index) => `arg${index}`).join(", ") +
          ");",
        "}",
        "};",
      ];
    }),
  ].join("\n");
}

async function run() {
  await fs.promises.mkdir(WEAK_NODE_API_PATH, { recursive: true });

  const nodeApiFunctions = getNodeApiFunctions();

  const header = generateHeader(nodeApiFunctions);
  const headerPath = path.join(WEAK_NODE_API_PATH, "weak_node_api.hpp");
  await fs.promises.writeFile(headerPath, header, "utf-8");
  cp.spawnSync("clang-format", ["-i", headerPath], { stdio: "inherit" });

  const source = generateSource(nodeApiFunctions);
  const sourcePath = path.join(WEAK_NODE_API_PATH, "weak_node_api.cpp");
  await fs.promises.writeFile(sourcePath, source, "utf-8");
  cp.spawnSync("clang-format", ["-i", sourcePath], { stdio: "inherit" });
}

run().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
