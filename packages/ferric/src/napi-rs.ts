import assert from "node:assert/strict";
import fs from "node:fs";
import path from "node:path";

import { NapiCli } from "@napi-rs/cli";

const napiCli = new NapiCli();

import { getBlockComment } from "./banner.js";

const PACKAGE_ROOT = path.join(import.meta.dirname, "..");

type TypeScriptDeclarationsOptions = {
  /**
   * Path to the directory containing the Cargo.toml file.
   */
  createPath: string;
  /**
   * Path to the output directory where the TypeScript declarations will be copied into.
   */
  outputPath: string;
  /**
   * File name of the generated TypeScript declarations (including .d.ts).
   */
  outputFilename: string;
};

export async function generateTypeScriptDeclarations({
  createPath,
  outputPath,
  outputFilename,
}: TypeScriptDeclarationsOptions) {
  // Using a temporary directory to avoid polluting crate with any other side-effects for generating TypeScript declarations
  const tempPath = fs.realpathSync(
    fs.mkdtempSync(path.join(PACKAGE_ROOT, "dts-tmp-")),
  );
  const finalOutputPath = path.join(outputPath, outputFilename);
  try {
    // Write a dummy package.json file to avoid errors from napi-rs
    await fs.promises.writeFile(
      path.join(tempPath, "package.json"),
      "{}",
      "utf8",
    );
    const tempOutputPath = path.join(tempPath, outputFilename);
    // Call into napi.rs to generate TypeScript declarations
    const { task } = await napiCli.build({
      verbose: false,
      dts: outputFilename,
      outputDir: tempPath,
      cwd: createPath,
      cargoOptions: ["--quiet"],
    });
    await task;
    // Override the banner
    assert(
      fs.existsSync(tempOutputPath),
      `Expected napi.rs to emit ${tempOutputPath}`,
    );
    const contents = await fs.promises.readFile(tempOutputPath, "utf8");
    const patchedContents = contents.replace(
      "/* auto-generated by NAPI-RS */",
      getBlockComment(),
    );
    // Copy out the generated TypeScript declarations
    await fs.promises.writeFile(finalOutputPath, patchedContents, {
      encoding: "utf8",
    });
    return finalOutputPath;
  } finally {
    await fs.promises.rm(tempPath, { recursive: true, force: true });
  }
}
