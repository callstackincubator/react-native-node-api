import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";

import {
  FunctionDecl,
  getNodeApiFunctions,
} from "../src/node-api-functions.js";

export const OUTPUT_PATH = path.join(import.meta.dirname, "../generated");

type GenerateFileOptions = {
  functions: FunctionDecl[];
  fileName: string;
  generator: (functions: FunctionDecl[]) => string;
};

async function generateFile({
  functions,
  fileName,
  generator,
}: GenerateFileOptions) {
  const output = generator(functions);
  const outputPath = path.join(OUTPUT_PATH, fileName);
  await fs.promises.writeFile(outputPath, output, "utf-8");
  cp.spawnSync("clang-format", ["-i", outputPath], { stdio: "inherit" });
}

async function run() {
  await fs.promises.mkdir(OUTPUT_PATH, { recursive: true });

  const functions = getNodeApiFunctions();
  await generateFile({
    functions,
    fileName: "weak_node_api.hpp",
    generator: generateHeader,
  });
  await generateFile({
    functions,
    fileName: "weak_node_api.cpp",
    generator: generateSource,
  });
}

export function generateFunctionDecl({
  returnType,
  name,
  argumentTypes,
}: FunctionDecl) {
  return `${returnType} (*${name})(${argumentTypes.join(", ")});`;
}

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateHeader(functions: FunctionDecl[]) {
  return `
    // This file is generated by react-native-node-api
    #include <node_api.h> // Node-API
    #include <stdio.h> // fprintf()
    #include <stdlib.h> // abort()

    // Ideally we would have just used NAPI_NO_RETURN, but
    // __declspec(noreturn) (when building with Microsoft Visual C++) cannot be used on members of a struct
    // TODO: If we targeted C++23 we could use std::unreachable()

    #if defined(__GNUC__)
    #define WEAK_NODE_API_UNREACHABLE __builtin_unreachable();
    #else
    #define WEAK_NODE_API_UNREACHABLE __assume(0);
    #endif
    
    // Generate the struct of function pointers
    struct WeakNodeApiHost {
      ${functions.map(generateFunctionDecl).join("\n")}
    };
    typedef void(*InjectHostFunction)(const WeakNodeApiHost&);
    extern "C" void inject_weak_node_api_host(const WeakNodeApiHost& host);
  `;
}

function generateFunctionImpl({
  returnType,
  name,
  argumentTypes,
  noReturn,
}: FunctionDecl) {
  return `
    extern "C" ${returnType} ${name}(
      ${argumentTypes.map((type, index) => `${type} arg${index}`).join(", ")}
    ) {
      if (g_host.${name} == nullptr) {
        fprintf(stderr, "Node-API function '${name}' called before it was injected!\\n");
        abort();
      }
      ${returnType === "void" ? "" : "return "} g_host.${name}(
        ${argumentTypes.map((_, index) => `arg${index}`).join(", ")}
      );
      ${noReturn ? "WEAK_NODE_API_UNREACHABLE" : ""}
    };
  `;
}

/**
 * Generates source code for a version script for the given Node API version.
 */
export function generateSource(functions: FunctionDecl[]) {
  return `
    // This file is generated by react-native-node-api
    #include "weak_node_api.hpp" // Generated header

    WeakNodeApiHost g_host;
    void inject_weak_node_api_host(const WeakNodeApiHost& host) {
      g_host = host;
    };
    
    // Generate function calling into the host
    ${functions.map(generateFunctionImpl).join("\n")}
  `;
}

run().catch((err) => {
  console.error(err);
  process.exitCode = 1;
});
